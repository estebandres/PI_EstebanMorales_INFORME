% Chapter Template

\chapter{Diseño} % Main chapter title

\label{Chapter5} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

\lhead{Capítulo  4. \emph{Diseño}} % Change X to a consecutive number; this is for the header on each page - perhaps a shortened title
Este capitulo se dedica a explorar los aspectos más relevantes relacionados con el diseño de la solución.

En primera instancia se plantea la necesidad de elegir y emplear un patrón de arquitectura de software 
para llevar a cabo la implementación de la aplicación. Brevemente se introducen los beneficios que motivaron la decisión de 
encuadrar las tareas de codificación bajo los lineamientos de la arquitectura seleccionada.

Se mencionan cada uno de los principios de diseño propuestos por la arquitectura y las repercusiones que deberían tener tanto en la estructura de la implementación como en su proceso.
Como parte de la descripción técnica se listan las partes constituyentes propuestas, se detallan las características más relevantes, sus responsabilidades y la relación entre ellas.

Quizás la propiedad más crítica de un diseño como el sugerido es la comunicación entre sus componentes.
Para su puesta en práctica se propuso utilizar el paradigma de programación reactiva. Se conoce a priori que esta nueva forma de pensar el software lleva adjunta una pronunciada curva de aprendizaje que implica una re-formulación
transversal del modo de codificación y resolución de los algoritmos en general. 
Teniendo en cuenta el impacto de esta decisión de diseño se hace necesario incluir una reseña de sus características principales.

Dado que el producto final incluye un modulo electrónico y un servicio online es imperativo definir con anticipación una interfaz de comunicación entre los subsistemas.

Así mismo, debido a la naturaleza de los requerimientos definidos en el capítulo ~\ref{Chapter4} deben incluirse como parte del diseño diversos protocolos de comunicación, se mencionan sus características principales y se justifica su empleo en el funcionamiento del producto.

\section{Arquitectura de Software}

Para realizar la implementación de la aplicación cliente se eligió la plataforma de desarrollo para dispositivos android, más precisamente teléfonos inteligentes y tabletas.

El objetivo principal de emplear una estructura fija para la implementación del proyecto es utilizar un único "lenguaje arquitectónico" que resulte familiar a los integrantes de un posible equipo de desarrollo y que sea transversal tanto para la implementación android, iOS o cualquier otra plataforma que pueda aparecer durante la vida útil del producto. De esta manera no es necesario pagar un costo demasiado alto al incluir una implementación del mismo sistema para una plataforma distinta. 
Los equipos de cada una de estas implementaciones podrán discutir aspectos de diseño, validar reglas de negocio y evacuar dudas sin tener en cuenta los detalles de las plataformas, así mismo será más fácil conservar coherencia y mostrar armonía entre las implementaciones nativas para dichas plataformas.

\subsection{Clean Architecture}
También conocida como arquitectura de capas (Onion Architecture). Su característica distintiva es que coloca la lógica de negocio, también conocido como dominio, al centro del diseño, es decir justo al medio entre las entradas y las salidas del sistema\cite{clean_bob}.\\

El \textbf{\emph{Principio Fundamental}}\label{text:Clean_Princ_Fund} de esta arquitectura puede resumirse en una frase: \textit{``Las capas internas contienen lógica de negocios, las capas externas detalles de implementación''}.

\subsubsection{Dominio Transparente}
Al listarse los directorios de un proyecto que cumple con los lineamiento de esta arquitectura, con tan solo leer el nombre de las carpetas debería ser posible, casi de inmediato, tener una idea de qué se trata esta aplicación, independientemente de la tecnología. Todo lo demás es un \emph{detalle de implementación}\cite{clean_five}.

Esta arquitectura propone un conjunto de características que debería seguir el proyecto que la implementa:

\begin{itemize}
	\item Regla de dependencia
	\item Abstracción
	\item Comunicación entre Capas
\end{itemize}
\subsubsection{Regla de Dependencias}
\emph{Las capas externas deben depender de las capas internas}. Permaneciendo en el centro las entidades del dominio inmediatamente seguidas por los objetos que encapsulan la lógica de negocio y que tienen acceso a tal dominio.  En la Figura ~\ref{fig:Diagrama_clasico} se muestran tres flechas en un recuadro rojo que representan el sentido de las dependencias. 

En lugar de emplear el verbo ``depende'', tal vez sea mejor usar términos como ``ve'', ``conoce'' o ``está consciente de...''. En estos términos, las capas externas \emph{ven, conocen y son conscientes} de las capas internas, pero el recíproco está prohibido como regla de diseño. Como se mencionó anteriormente, las capas internas contienen lógica de negocio y las externas los detalles de implementación. Combinado con el Principio Fundamental ~\ref{text:Clean_Princ_Fund}, se deduce que la lógica de negocio no ve, ni conoce detalles de implementación.

No existe una única forma de implementar esta regla. Una estrategia consiste en colocar las clases de cada capa en paquetes diferentes, poniendo especial cuidado en no importar paquetes ``externos'' en paquetes ``internos''. Sin embargo, si algún programador del equipo no es consciente del principio de dependencias, nada le impediría incumplirlo. Otro enfoque un tanto más sofisticado consiste en separar las capas en diferentes módulos de construcción independiente, y ajustar las dependencias en el archivo de construcción para que la capa interna simplemente no pueda utilizar la capa externa, sin embargo este enfoque implica un exhaustivo conocimiento de la herramienta de construcción de la plataforma para la que se está desarrollando. Por esta razón para el presente proyecto se optó por la primera alternativa.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{Figures/-001.png}
	\rule{35em}{1pt}
	\caption[Principio de Dependecias]{Esquema de dependencias para una arquitectura en capas.}
	\label{fig:Diagrama_clasico}
\end{figure}

\subsubsection{Principio de Abstracción}
El principio de abstracción ya se ha insinuado antes. Postula que, a medida que se recorre el diagrama circular de la Figura ~\ref{fig:C2_PA} a lo largo del radio en dirección del centro, las implementaciones se vuelven más abstractas, agnósticas de plataformas y frameworks. Como se mencionó en la sección anterior, el círculo interno contiene lógica de negocios mientras que el exterior comprende los detalles de implementación.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{Figures/-002.png}
	\rule{35em}{1pt}
	\caption[Abstraction Principle]{Principio de Abstracción en una arquitectura por capas.}
	\label{fig:C2_PA}
\end{figure}

\subsubsection{Comunicación entre Capas}
Dado que en esta arquitectura la lógica de negocio se encuentra en el centro del diseño, ésta debe mediar entre los componentes periféricos de entrada y salida.
Aquí se presenta un inconveniente paradójico introducido por el empleo de la regla de dependencias: la capa con lógica de negocios ni siquiera conoce que los componentes en la periferia existen.
Esto representa un desafío ya que necesitamos que los datos sean capaces de fluir desde las capas externas a las internas y viceversa, esto sin violar la regla de dependencias.


Se propone entonces un método para resolver el problema de comunicación entre capas.
En primera instancia se define los objetos \emph{Caso de Uso} como las entidades principales de la Lógica de Negocios.
Se conceptualizan dos puertos para cada caso de uso, uno de entrada y otro de salida.
Mediante el puerto de entrada se reciben parámetros para la ejecución del caso de uso mientras que el puerto de salida permite la extracción de sus resultados.
En la práctica, la definición de estos puertos (interfaces) se realiza dentro de la capa más interna mientras que su implementación e instanciación en la capa más externa. Esto satisface la regla de dependencias y puede visualizarse en la Figura ~\ref{fig:C2_CC_01}.


\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{Figures/-004.png}
	\rule{35em}{1pt}
	\caption[Layer Communication]{Comunicación entre capas.}
	\label{fig:C2_CC_01}
\end{figure}


\section{Diseño de Capas}
Como parte del proyecto de PPS se investigaron implementaciones reales de esta arquitectura en proyectos android.
Las dos mejores disponibles a código abierto y con buena documentación pertenecen a un desarrollador argentino Fernando Cejas \cite{clean_cejas} (SoundCloud) y al repositorio de Blueprints Arquitectónicos de Google\cite{clean_android_blueprints}.\\
Ambas propuestas dividen la implementación en tres capas principales, una capa de presentación, una capa de dominio y la capa de datos.
Cada capa tiene una responsabilidad bien definida y se comunica con una única capa vecina respetando la regla de dependencias.
La cadena de comunicación puede apreciarse en la figura ~\ref{fig:Diagrama_clasico2}. La capa de presentación transmite las acciones del usuario a la capa de dominio, la cual efectúa solicitudes de información a la capa de datos. Una vez resueltas, la capa de datos enviará los resultados de vuelta a la capa de dominio que ejecutará la lógica de negocios correspondiente. Esto genera una respuesta que, a su vez, produce los efectos deseados en la capa de presentación.\\
\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.3\textwidth]{Figures/-006.png}
	\rule{35em}{1pt}
	\caption[Dependencia de Módulos]{Esquema de dependencias para una arquitectura en capas.}
	\label{fig:Diagrama_clasico2}
\end{figure}
A continuación se describe brevemente las responsabilidades de cada capa.


\begin{itemize}
	\item Capa de Presentación: Esta capa se encarga de presentar la interfaz de usuario, esto es, mostrar por pantalla los objetos visuales correspondientes y recibir los eventos de interacción que realiza el usuario. Para la implementación se recomienda el empleo del patrón de diseño conocido como \textbf{MVP (Model View Presenter)}. 
	\item Capa de Dominio: Esta capa contiene toda la lógica de negocio. La capa de dominio contiene las clases denominadas casos de uso o interactores según la literatura. Estos objetos encapsulan los escenarios contemplados por la lógica de negocio y son ejecutados por la capa de presentación. Estos casos de uso representan todas las acciones posibles admitidas por el sistema y que pueden ser compuestas en la implementación por los desarrolladores siempre desde la capa de presentación. Para la implementación de estos casos de uso se sugiere la utilización del patrón de diseño conocido como \textbf{Command Pattern}.
	\item Capa de Datos: Esta capa administra la adquisición de datos y es capaz de utilizar diferentes orígenes de datos, así como la lógica de cache o persistencia temporal. Esta capa se suele implementar utilizando el patrón de diseño conocido como \textbf{Repository Pattern}.  
\end{itemize}
\subsection{Capa de Presentación: Model View Presenter (MVP)}
\subsection{Capa de Dominio: Patrón Command}
\subsection{Capa de Datos: Patrón Repository}

\section{Programación Reactiva}
\subsection{Aplicación sobre la Arquitectura}

\section{Interfaz Módulo - Aplicación}
\subsection{RPC API}
\begin{sidewaystable}[!htbp] 
	\scriptsize
	\rowcolors*{1}{black!10}{}
	\begin{tabularx}{\columnwidth}{|c|>{\bfseries\ttfamily}l|>{\raggedright\arraybackslash}X|>{\ttfamily}X|>{\ttfamily}X|>{\tiny\ttfamily}X|}
		\hline
		\multicolumn{1}{|>{\bfseries}c|}{Código} & \multicolumn{1}{>{\bfseries}c|}{Protocolo} & \multicolumn{1}{>{\bfseries}c|}{Descripción}  & \multicolumn{1}{>{\bfseries}c|}{Argumentos} & \multicolumn{1}{>{\bfseries}c|}{Respuesta} & \multicolumn{1}{>{\bfseries}X|}{Errores
			\newline \tiny\texttt{401 Unauthorized  \newline
				403 Forbidden \newline \{``code'':int, ``message'':string\}}{}  } \\ \hline
		
		100  & Admin.FactoryReset   & Elimina las configuraciones y los usuarios registrados. & \{\}    & 
		\{"message":string\} &  \\  \hline
		
		101  & Admin.SetWiFiAP      &  Conecta el módulo a un Access Point WiFi.     &   \{"ssid": "string","password"": "string"\}      &  \{"message":string\}      &    	
		400 Bad Request \newline
		[ssid and password required] \newline
		[wrong ssid or password] \\ \hline
		
		102  & Admin.GetUsers       &  Devuelve la lista de usuarios.    &   \{\}      &   \{``users'': [\{``user\_name'':string, ``user\_type'':int\}]\}     &    \\ \hline
		 
		103  & Admin.UpdateUser     &   Cambia el nivel de privilegio del usuario pasado como parametro   &   \{``user\_name'':string, ``user\_type'':int\}      &   \{"message":``user updated''\}     &   
		400 Bad Request \newline
		[username or type incorrect] \newline
		404 Not Found \newline
		[user not found]    \\ \hline
		
		104  & Admin.DeleteUser     &   Elimina un usuario del módulo   &   \{``user\_name'':string\}      &     \{"message":``user deleted''\}    &   
		404 Not Found \newline
		[user not found] \newline
		500 Internal Error \newline
		[user not deleted from server] \\ \hline
		
		105  & Admin.Trigger        &   Acciona el módulo   &   \{\}      &    \{"message":``Triggering gate''\}     &   
		500 Internal Error \newline
		[user changed type]
		\\ \hline
		106  & Admin.CreateUser     &   Crea un usuario provisorio, pendiente de aprobación.   &    \{``user\_name'':string\}     &   \{``user\_type'':int\}     &    
		400 Bad Request\newline
		[credentials parameter is required]\newline
		[credentials error]\newline
		409 Conflict\newline
		[user already exists]\newline
		412 Precondition Failed\newline
		[user's max qty reached]
		
		\\ \hline
		107  & Admin.EnableUpdate   &   Habilita el proceso de actualización del firmware del módulo   &    \{\}     &     \{"message":``OTA Update Enabled''\}     &      \\ \hline
		108  & Admin.SetGateStatus  &  Cambia el estado de apertura    &    \{``status\_code'':int\}     &   \{``status\_code'':int\}     &   
		\\ \hline
		109  & Admin.GetGateStatus  &   Devuelve el estado de apertura   &    \{\}     &   \{``status\_code'':int, ``opening\_percentage'':int\}     &      \\ \hline
		200  & Guest.CreateUser     &   Crea una solicitud de acceso   &   \{``credentials'':string\}      &    \{``user\_type'':int\}    &   
		\textbf{IDEM 106 \newline No Aplican Errores 401 y 403}
		\\ \hline
		201  & Guest.UserStatus     &   Devuelve el nivel del usuario solicitado   &    \{``user\_name'':string\}     &   \{``user\_name'':string, ``user\_type'':int\}     &  
		\textbf{No Aplican Errores 401 y 403}\newline
		400 Bad Request\newline
		[User Name is required]\newline
		404 Not Found \newline
		[user not found] \newline
		\\ \hline
		203  & Sys.GetInfo          &      &         &        &      \\ \hline
		300  & User.Trigger         &  \multicolumn{4}{|X|}{\scriptsize{\textbf{IDEM 105}} }   \\ \hline
		301  & User.GetGateStatus   &   \multicolumn{4}{|l|}{\scriptsize{\textbf{IDEM 109}} }      \\ \hline
		& /update&    \multicolumn{4}{|l|}{\scriptsize{\textbf{Envía el nuevo firmware como un POST multiparte fijando el parámetro commit\_timeout=75 (segundos).}} }  \\ \hline
		& /update/commit       &   \multicolumn{4}{|l|}{\scriptsize{\textbf{Se confirma la correcta actualización ejecutando el RPC OTA.Commit con un POST a este endpoint}} }     \\ \hline
	\end{tabularx}
	\caption{Protocolos remotos proporcionados por el firmware del modulo}
\end{sidewaystable}

\section{Protocolos de Comunicación}
\subsection{MDNS DNS-SD}
\subsection{HTTP y Digest Authentication}
\subsection{MQTT}

